<?xml version="1.0"?>

<bindings id="code_editor"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xbl="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul">
<!--
  (c) Original code by Anton from forum.mozilla.ru
-->

 <binding id="accelkeytextboxbinding" extends="chrome://global/content/bindings/textbox.xml#textbox">
  <implementation>
   <constructor>
    <![CDATA[
     this. keymap = new Array ();
     var prefix = "DOM_VK_";
     for (var i in KeyEvent)
     {
      if (i. indexOf (prefix) == 0)
       this. keymap [KeyEvent [i]] = i. substr (prefix. length);
     }
    ]]>
   </constructor>

   <destructor>
    <![CDATA[
     this. keymap = null;
    ]]>
   </destructor>

   <field name="keymap">null</field>

   <method name="getKey">
    <parameter name="event"/>
    <body>
     <![CDATA[
      if (event. which)
       return String. fromCharCode (event. which);
      else
       return this. keymap [event. keyCode];
     ]]>
    </body>
   </method>

  </implementation>

  <handlers>
   <handler event="keypress" phase="capturing">
    <![CDATA[
     var key = this. getKey (event);
     if (key == "TAB")
      return;
     if (key == "ESCAPE")
     {
      this. value = "";
      event. preventDefault ();
      return;
     }
     var alt = event. altKey;
     var ctrl = event. ctrlKey;
     var shift = event. shiftKey;
     var text = "";
     if (alt) text = "Alt+";
     if (ctrl) text += "Ctrl+";
     if (shift) text += "Shift+";
     this. value = text + key;
     event. preventDefault ();
     event. stopPropagation ();
    ]]>
   </handler>
  </handlers>
 </binding>

 <binding id="code_editor_binding" extends="chrome://global/content/bindings/textbox.xml#textarea">
  <implementation>
   <constructor>
    <![CDATA[
      try
      {
       var sCh = this. spellCheckerUI;
        if (sCh)
         sCh. mInlineSpellChecker. enableRealTimeSpell = false;
       }
       catch (e) {}
      ]]>
   </constructor>
   <field name="currentIndent"/>
   <method name="getLines">
    <body>
     <![CDATA[
      var arr = this. value. split ("\n");
      arr. forEach
      (
       function (el, index, arr)
       {
        arr [index] = [el, el. length + 1];
        if (index != 0)
         arr [index] [1] += arr [index - 1] [1];
       }
      );
      return arr;
     ]]>
    </body>
   </method>
   <method name="setLines">
    <parameter name="linesArr"/>
    <body>
     <![CDATA[
      var st = this. inputField. scrollTop;
      var sl = this. inputField. scrollLeft;
      linesArr. forEach
      (
       function (el, index, arr)
       {
        arr [index] = arr [index]. shift ();
       }
      );
      this. value = linesArr. join ("\n");
      this. inputField. scrollTop = st;
      this. inputField. scrollLeft = sl;
     ]]>
    </body>
   </method>
   <method name="getSelLinesRange">
    <body>
     <![CDATA[
      var arr = this. getLines ();
      var startLine = 0, endLine = 0, i = 0;
      while (arr [i] [1] <= this. selectionStart)
       startLine = ++i;
      i = 0;
      while (arr [i] [1] <= this. selectionEnd)
       endLine = ++i;
      return [startLine, endLine];
     ]]>
    </body>
   </method>
  </implementation>
  <handlers>
   <handler event="keypress" preventdefault="true" key="a"
      modifiers="control,shift">
    <![CDATA[
     var i, scf;
     var arr = this. getLines ();
     var range = this. getSelLinesRange ();
     var sp = this. selectionStart, ep = this. selectionEnd;
     var d = 0;
     scf = (arr [range [0]] [0]. indexOf ("//") != 0);
     sp += (scf? 2: -2);
     if (sp < 0)
      sp = 0;
     for (i = range [0]; i <= range [1]; i++)
     {
      if (scf)
       arr [i] [0] = "//" + arr [i] [0];
      else if (/^\/\//. test (arr [i] [0]))
      {
       arr [i] [0] = arr [i] [0]. replace (/^\/\//, "");
       d++;
      }
     }
     this. setLines (arr);
     if (!scf)
      d = -(2 * d);
     else
      d = (range [1] - range [0] + 1) * 2;
     this. setSelectionRange (sp, ep + d);
    ]]>
   </handler>
   <handler event="keydown" preventdefault="true" phase="capturing"
      keycode="VK_TAB">
    <![CDATA[
     if (this. selectionStart == this. selectionEnd)
     {
      var e = document. createEvent ("KeyEvents");
      e. initKeyEvent
      (
       "keypress", event. cancelable, event. canBubble,
       event. view, false, false, false, false, 0, 9
      );
      this. inputField. dispatchEvent (e);
      return;
     }
     var i;
     var arr = this. getLines ();
     var range = this. getSelLinesRange ();
     var sp = this. selectionStart, ep = this. selectionEnd;
     var d = range [1] - range [0] + 1;
     for (i = range [0]; i <= range [1]; i++)
     {
      arr [i] [0] = "\t" + arr [i] [0];
     }
     this. setLines (arr);
     this. setSelectionRange (sp + 1, ep + d);
    ]]>
   </handler>
   <handler event="keydown" preventdefault="true" phase="capturing"
      keycode="VK_TAB" modifiers="shift">
    <![CDATA[
     var i;
     var arr = this. getLines ();
     var range = this. getSelLinesRange ();
     var sp = this. selectionStart - 1, ep = this. selectionEnd;
     if (sp < 0)
      sp = 0;
     var d = 0;
     for (i = range [0]; i <= range [1]; i++)
      if (/(^\s*?)\t/. test (arr [i] [0]))
      {
       arr [i] [0] = arr [i] [0]. replace (/(^\s*?)\t/, "$1");
       d++;
      }
     if (d != 0)
     {
      this. setLines (arr);
      this. setSelectionRange (sp, ep - d);
     }
    ]]>
   </handler>
   <handler event="keydown" keycode="VK_RETURN">
    <![CDATA[

//     var arr = this. getLines ();
//     var range = this. getSelLinesRange ();
//     this. currentIndent = arr [range [0]] [0]. match (/^([ \t]*)?/) [0];
     //берётся подстрока от начала строки до позиции курсора
     var selStart = this. selectionStart;
     this. currentIndent = this. value. substring
     (
       this. value. lastIndexOf ('\n', selStart) + 1, selStart
     ). match (/^([ \t]*)?/) [0];
    ]]>
   </handler>
   <handler event="keyup" keycode="VK_RETURN">
    <![CDATA[
     if (!this. currentIndent)
      return;

     // Защита от ложного срабатывания когда код выполняется по F9,
     // в коде алерт, и он закрывается нажатием ENTER
     var selStart = this. selectionStart;
     if (this. value. substring (selStart - 1, selStart). charCodeAt (0) != 10)
      return;

     var i, cc, e;
     for (i = 0; i < this. currentIndent. length; i++)
     {
      e = document. createEvent ("KeyEvents");
      cc = this. currentIndent. charAt (i);
      if (cc == " ")
       e. initKeyEvent
       (
        "keypress", true, true, event. view, false,
        false, false, false, 32, 32
       );
      else
       e. initKeyEvent
       (
        "keypress", true, true, event. view, false,
        false, false, false, 0, 9
       );
      this. inputField. dispatchEvent (e);
     }
    ]]>
   </handler>

  <!--Executing code from the "Code" field-->
   <handler event="keydown" keycode="VK_F9">
    <![CDATA[
     if (this. getAttribute ("id") == "code")
      window. editor. execute_oncommand_code ();
    ]]>
   </handler>
  </handlers>
 </binding>

</bindings>
